# 서포트 벡터 머신 (support vector machine)
### 최대 마진 분류기
선형 + 하드 마진
### 서포트 벡터 분류기
선형 + 소프트 마진
### 서포트 벡터 머신
비선형 + 소프트 마진

***

## 초평면 (hyperplane)
- 초평면 : p차원의 공간에서 초평면은 차원이 p-1인 평평한 부분 공간, 한 차원 낮은 점들의 모임
- 예시 : 2차원에서 초평면은 선이므로, 초평면은 b0+b1x1+b2x2=0로 정의될 수 있다
- 위 식을 만족하는 X는 초평면 위에 있다
- 분리 초평면 (separating hyperplane) : 관측치를 클래스 라벨에 따라 분리하는 초평면
- 분리 초평면이 존재하면, 검정 관측치는 초평면 어느 쪽에 위치하는지에 따라 클래스에 할당된다
- 분리 초평면에 기초한 분류기는 **선형** 결정경계로 이어진다

## 최대 마진 분류기
- 무한개의 분리 초평면 중 훈련 관측치로부터 가장 멀리 떨어진 분리 초평면을 최대 마진 초평면이라 한다
- 각각의 훈련 관측치에서 주어진 초평면까지의 수직 거리들 중에 가장 짧은 거리를 마진(margin)이라 한다
- 훈련 관측치들까지의 최소 거리를 가장 멀게 하는 초평면으로 관측치를 분류하는 것을 최대 마진 분류기라 한다 
- 최대 마진 초평면에서 동일한 거리에 있고 마진의 폭에 놓여있는 관측치 = 서포트 벡터 (support vector)
- 이 점들이 이동하면 최대 마진 초평면도 이동될 것이라는 의미에서 최대 마진 초평면을 서포트한다고 할 수 있다
- **최대 마진 초평면이 관측치의 작은 부분집합(서포트 벡터들)에만 직접적으로 의존한다는 사실 중요**

## 서포트 벡터 분류기
- 최대 마진 분류기를 분류할 수 없는 경우로 일반화한 것이 서포트 벡터 분류기
- 최대 마진 분류기에 비해 (1) 개별 관측치에 대해 더 로버스트하다 (2) 대부분의 훈련 관측치들을 더 잘 분류한다
- 마진을 소프트하게 잡기 때문에(분류가 완벽하게 안 되고 살짝 틀려도 ok), 소프트 마진 분류기라고도 한다
- 가능한 가장 큰 마진을 찾는 대신에 일부 관측치들이 잘못 분류된 것을 허용한다
- 관측치들이 마진의 옳지 않은 쪽, 그 너머 초평면의 옳지 않은 쪽에 있을 수도 있다
- 최대 마진 분류기의 최적화 문제에 슬랙 변수와 조율 파라미터가 추가된다
- 조율 파라미터 C는 마진이 위반될 수 있는 양에 대한 예산이며, 클수록 허용 수준이 높아진다
- 조율 파라미터 C는 편향-분산 절충을 제어하며, 작을수록 데이터에 고도로 적합되어 분산이 높을 수 있다
- 조율 파라미터 C가 커지면, 에러 허용치와 서포트 벡터 수가 많아진다
- 여기서 서포트 벡터 = 마진 위에 있거나 옳지 않은 쪽에 있는 관측치들

## 서포트 벡터 머신 (SVM)
- 비선형 경계를 수용하기 위해 차원을 늘려서 해결
- 즉, 설명변수들의 높은 차수의 다항식 함수들을 사용해 변수 공간을 확장
- SVC 문제에 대한 해는 내적(inner products)만이 관련 되며, 파라미터 알파는 서포트 벡터에 대해서만 영이 아니다
- 내적의 일반화된 형태를 K(xi, xi\`)라고 하며, K는 커널 함수다. 커널은 두 관측치들의 유사성을 수량화하는 함수다.
- 표준 선형커널 대신 d>1인 커널을 SVC 알고리즘에 사용하면 유연한 결정경계가 만들어진다
- 원래의 변수 공간이 아니라 한 차원 높은 공간(차수가 d인)에 SVC를 적합하는 것 
- 서포트 벡터 분류기는 차수 d=1인 다항식 커널을 사용하는 서포트 벡터 머신과 같다
- 비선형 커널에는 다항식 커널, 방사 커널(radial kernel) 등이 있다
- 커널을 사용하는 장점은 단지 K(xi, xi\`)만을 계산하면 되는, 계산상의 이점이 있다

## 로지스틱 회귀와의 상관관계
- SVM을 다시 정리하면 "손실 + 패널티" 형태를 취한다
- lambda가 클 때, 마진에 대한 더 많은 위반이 용인되어 분산은 낮기만 편향이 높은 분류기가 된다
- lambda가 작을 때, 마진에 대한 위반이 거의 발생하지 않아 분산은 높지만 편향이 낮은 분류기가 된다
- 손실함수의 유사성 때문에, 로지스틱 위귀와 SVM은 보통 매우 흡사한 결과를 준다
- 클래스들이 잘 분리되어 있을 때에는 SVM, 겹칠 때는 로지스틱이 선호된다
